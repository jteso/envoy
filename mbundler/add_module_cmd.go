package mbundler

import (
	"io/ioutil"
	"os"
	"path"
	"path/filepath"
	"text/template"
)

const auto_loader_template = `// This file has to be automatically generated. Do NOT edit it!!
package modulebundler

import (
	"bitbucket.org/ligrecito/logutils"
	{{range . }}
	_ "{{.}}"
	{{end}}
)

var logger = logutils.New(logutils.ConsoleFilter)

func LoadModules() {
	logger.Debug("Loading all modules...")
}
`

// ImportModule will import the 3rd party developed module into backplane.
// This process will take the following steps:
// 1. `go get` the source code of BP
// 2. The new module ('modulepath') will be copied into the sources under the module directory.
// 3. `Load_modules.go` will be autogenerated in order to automatically reload the new module
// 4. `go install` will recompile the solution. The new build will include the new module

func ImportModule(modulepath string) {
	// this will be the package path for the 3rd party module
	modulepath = "bitbucket.com/ligrecito/backplane-engine/modules/" + modulepath

	gopath := os.Getenv("GOPATH") //FIXME: @javier - fallback strategy??
	modules_path_relative := "bitbucket.com/ligrecito/backplane-engine/modules"
	modules_path_abs := path.Join(gopath, "src", modules_path_relative)

	packages := getModules(modules_path_abs, modules_path_relative)
	packages = append(packages, modulepath)
	packages = removeDuplicates(packages)

	writeTemplate(filepath.Join(".", "modulebundler", "load_modules.go"), auto_loader_template, packages)
}

func writeTemplate(filename, contents string, data interface{}) error {
	if err := os.MkdirAll(filepath.Dir(filename), 0755); err != nil {
		return err
	}

	t, err := template.New(filename).Parse(contents)
	if err != nil {
		return err
	}
	file, err := os.Create(filename)
	if err != nil {
		return err
	}
	defer file.Close()
	return t.Execute(file, data)
}

// Get all modules found in a given absolute path
func getModules(modules_path_abs string, modules_path_relative string) []string {
	found_modules := make([]string, 0)
	modules, _ := ioutil.ReadDir(modules_path_abs)

	for _, elem := range modules {
		if elem.IsDir() {
			found_modules = append(found_modules, path.Join(modules_path_relative, elem.Name()))
		}
	}
	return found_modules
}

func removeDuplicates(a []string) []string {
	result := []string{}
	seen := map[string]string{}
	for _, val := range a {
		if _, ok := seen[val]; !ok {
			result = append(result, val)
			seen[val] = val
		}
	}
	return result
}
